====================map====================
map一般不指定cap容量参数，如果需要使用比较大的map，最好能预估map的大小，初始化时设置合适的cap参数，能够避免map的自增长的消耗，提升程序的性能

====================sync.Pool====================
sync.Pool 其实更应该叫sync.Cache，也就是对象缓存，包含一个私有对象和Processor共享池，私有对象是协程安全的，共享池是协程不安全的，取对象的时候，先从私有对象里面取，因为这样协程安全不需要锁，开销最小，如果私有对象里面没有，那么就从当前协程所在的Processor共享池里面取，这个Processor共享池取不到就从另外一个Processor共享池里面取，如果都取不到，那就new一个出来，放进去的时候也是先往私有对象里面放，如果私有对象存在，就往当前协程所在的Processor共享池里面放。
sync.Pool不可以当缓存池用，因为这个对象的生命周期是不确定的，每一次gc都会清空sync.Pool的缓存对象。对象的缓存有效期为下一次gc之前。

====================完成任意任务====================
任意任务完成即可返回，可以使用channel，当收到第一个插入值就可以返回，注意要使用带缓存的channel防止协程泄漏。

====================完成所有任务====================
所有任务完成，也可以使用channel，等待已知个数的返回值即可。

====================goconvey====================
goconvey是一个测试框架

====================Benchmark====================
<!-- func BenchmarkConcatStringByAdd(b *testing.B) {
	// 与性能测试无关的代码
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// 测试代码
	}
	b.StopTimer()
	//与性能测试无关的代码
} -->

====================pprof进行性能分析====================
go 的性能分析使用pprof这个包，有多种prof文件，cpu内存等等。

====================golang高性能程序经验====================
高性能程序或者说是程序性能优化主要是分两部分，一个是程序逻辑部分的优化，一部分数据库那一部分的优化。
对于程序逻辑的性能优化，主要有以下几点：
1.尽量不使用锁哪怕是读写锁，对性能都是有不小影响的，会增加cpu的消耗

2.尽量不使用反射功能，例如json的编码和解析，go内置的json功能就是使用的反射，效率极低，在http服务中往往需要处理大量的数据交互，编码以及解析，使用go内置的json性能很差，可以使用第三方库easyjson替换或者使用其他编解码方式例如probuf

3.大量字符串连接时(例如写log时)不要直接相加，使用byte buf或者strings builder，这种在输出日志的地方会常常用到

4.函数参数传递能使用就尽量使用指针，避免不必要的数据拷贝

5.slice，map这种会自增长的数据类型，如果容量可以初始化到合适的大小，那是最好的，这样就不会频繁的自增长，不断的申请新的内存和数据拷贝，也减少了gc，这样就提升了性能，但是不能初始化非常大的slice和map，因为申请大内存本身的消耗就非常大，例如容量是10万级的map就不要初始化了，一般也用不到这么大的map

对于数据库那一部分的优化，目前以我的经验就是多节点读写分离，使用缓存（注意保持缓存一致性），合理的设计使用索引，合理的使用sql语句等等。

====================cookie和session区别====================
区别在于session是放在服务器上的，过期与否取决于服务期的设定，cookie是存在客户端的，过期与否可以在cookie生成的时候设置进去。

====================数据库的垂直切分与水平切分====================
垂直切分是根据业务来拆分数据库，就是按大类来分，同一类业务的数据表拆分到一个独立的数据库，另一类的数据表拆分到其他数据库。就是要把原来强耦合的系统拆分成多个弱耦合的服务，通过服务间的调用来满足业务需求看，因此表拆出来后要通过服务的形式暴露出去，而不是直接调用不同模块的表。电商在架构不断演变过程，最重要的一环就是服务化改造，把用户、交易、店铺、宝贝这些核心的概念抽取成独立的服务，也非常有利于进行局部的优化和治理，保障核心模块的稳定性。

垂直切分的缺点是单表大数据量依然存在性能瓶颈。

数据库的水平切分就是在一个大类之下分子类，把大表变成小表，当然这个子类的划分规则是要根据具体业务来制定的。例如商品表可以切分成鞋子，衣服等小表。

一般情况下都是先进行水平切分的，垂直切分的复杂度比较高。

一般情况下都是先进行水平切分，因为简单，逻辑清晰，表太大了，维护和查询的成本就很大，把大表先变小表是比较简单直接的优化思路。

数据库的压力变大，性能下降时，可以考虑加一个缓存来提升性能。然后也可以做一下数据分片，把数据按照某种规则分开存储，这种规则相当于一种索引了，这样也能很明显的提升数据库的性能。
再进一步，可以尝试读写分离了，再进一步可以进行冷热数据分离，定期归档。

数据库写入性能的提升，主要思路就是批量和减少刷盘的次数，批量写能极大的提升性能，减少刷盘次数可以把redo log的缓存区设置得大一点，减少数据库的checkpoint操作，可以把innodb_flush_log_at_trx_commit设置为0或者2，这样也能减少刷盘的次数。如果真的要为极端的情况做写入准备，我觉得可以牺牲查询的效率或者是延迟一下查询，先直接写nosql例如leveldb, 然后再归档到mysql，这样大概也能支持每秒10万笔的写入效率，对绝大多数情况应该也够用了。