====================map====================
map一般不指定cap容量参数，如果需要使用比较大的map，最好能预估map的大小，初始化时设置合适的cap参数，能够避免map的自增长的消耗，提升程序的性能

====================sync.Pool====================
sync.Pool 其实更应该叫sync.Cache，也就是对象缓存，包含一个私有对象和Processor共享池，私有对象是协程安全的，共享池是协程不安全的，取对象的时候，先从私有对象里面取，因为这样协程安全不需要锁，开销最小，如果私有对象里面没有，那么就从当前协程所在的Processor共享池里面取，这个Processor共享池取不到就从另外一个Processor共享池里面取，如果都取不到，那就new一个出来，放进去的时候也是先往私有对象里面放，如果私有对象存在，就往当前协程所在的Processor共享池里面放。
sync.Pool不可以当缓存池用，因为这个对象的生命周期是不确定的，每一次gc都会清空sync.Pool的缓存对象。对象的缓存有效期为下一次gc之前。

====================完成任意任务====================
任意任务完成即可返回，可以使用channel，当收到第一个插入值就可以返回，注意要使用带缓存的channel防止协程泄漏。

====================完成所有任务====================
所有任务完成，也可以使用channel，等待已知个数的返回值即可。

====================goconvey====================
goconvey是一个测试框架

====================Benchmark====================
<!-- func BenchmarkConcatStringByAdd(b *testing.B) {
	// 与性能测试无关的代码
	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		// 测试代码
	}
	b.StopTimer()
	//与性能测试无关的代码
} -->

====================pprof进行性能分析====================
go 的性能分析使用pprof这个包，有多种prof文件，cpu内存等等。

====================golang高性能程序经验====================
高性能程序或者说是程序性能优化主要是分两部分，一个是程序逻辑部分的优化，一部分数据库那一部分的优化。
对于程序逻辑的性能优化，主要有以下几点：
1.尽量不使用锁哪怕是读写锁，对性能都是有不小影响的，会增加cpu的消耗

2.尽量不使用反射功能，例如json的编码和解析，go内置的json功能就是使用的反射，效率极低，在http服务中往往需要处理大量的数据交互，编码以及解析，使用go内置的json性能很差，可以使用第三方库easyjson替换或者使用其他编解码方式例如probuf

3.大量字符串连接时(例如写log时)不要直接相加，使用byte buf或者strings builder，这种在输出日志的地方会常常用到

4.函数参数传递能使用就尽量使用指针，避免不必要的数据拷贝

5.slice，map这种会自增长的数据类型，如果容量可以初始化到合适的大小，那是最好的，这样就不会频繁的自增长，不断的申请新的内存和数据拷贝，也减少了gc，这样就提升了性能，但是不能初始化非常大的slice和map，因为申请大内存本身的消耗就非常大，例如容量是10万级的map就不要初始化了，一般也用不到这么大的map

对于数据库那一部分的优化，目前以我的经验就是多节点读写分离，使用缓存（注意保持缓存一致性），合理的设计使用索引，合理的使用sql语句等等。





